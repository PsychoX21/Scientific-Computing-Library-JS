var t;t=()=>(()=>{var t={d:(e,r)=>{for(var l in r)t.o(r,l)&&!t.o(e,l)&&Object.defineProperty(e,l,{enumerable:!0,get:r[l]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Bioinformatics:()=>c,CFD:()=>g,Complex:()=>i,Differential:()=>a,FEM:()=>f,FFT:()=>s,FFTApplications:()=>h,LinearSolvers:()=>o,MatrixOps:()=>n,ODEApplications:()=>u,ODESolvers:()=>r,RootFinding:()=>l,Stats:()=>m});class r{static euler(t,e,r,l,o,a=!1){let n=[[e,...r]],i=e,s=r;a&&console.log(`Euler Method Start: t0 = ${e}, h = ${l}, steps = ${o}`);for(let e=0;e<o;e++){let r=t(i,...s);a&&e%100==0&&console.log(`Step ${e+1}/${o}: t = ${i}, vars = ${s}`);for(let t=0;t<s.length;t++)s[t]+=l*r[t];i+=l,n.push([i,...s])}return a&&console.log("Euler Method End"),n}static rk4(t,e,r,l,o,a=!1){let n=[[e,...r]],i=e,s=r;a&&console.log(`RK4 Method Start: t0 = ${e}, h = ${l}, steps = ${o}`);for(let e=0;e<o;e++){let r=t(i,...s),c=t(i+l/2,...s.map(((t,e)=>t+l/2*r[e]))),g=t(i+l/2,...s.map(((t,e)=>t+l/2*c[e]))),f=t(i+l,...s.map(((t,e)=>t+l*g[e])));a&&e%100==0&&console.log(`Step ${e+1}/${o}: t = ${i}, k1 = ${r}, k2 = ${c}, k3 = ${g}, k4 = ${f}`);for(let t=0;t<s.length;t++)s[t]+=l/6*(r[t]+2*c[t]+2*g[t]+f[t]);i+=l,n.push([i,...s])}return a&&console.log("RK4 Method End"),n}static euler2(t,e,r,l,o,a,n=!1){let i=l,s=e,c=r,g=[[i,s,c]];n&&console.log(`Euler2 Method Start: t0 = ${l}, h = ${a}, tEnd = ${o}`);let f=0;for(;i<o;){let e=t(i,s,c);n&&f%100==0&&console.log(`Step ${f+1}: t = ${i}, y = ${s}, v = ${c}, acceleration = ${e}`),s+=a*c,c+=a*e,i+=a,g.push([i,s,c]),f++}return n&&console.log("Euler2 Method End"),g}static rk4_2nd(t,e,r,l,o,a,n=!1){let i=l,s=e,c=r,g=[[i,s,c]];n&&console.log(`RK4_2nd Method Start: t0 = ${l}, h = ${a}, tEnd = ${o}`);let f=0;for(;i<o;){let e=a*t(i,s,c),r=a*c,l=a*t(i+a/2,s+r/2,c+e/2),o=a*(c+e/2),u=a*t(i+a/2,s+o/2,c+l/2),h=a*(c+l/2),m=a*t(i+a,s+h,c+u),d=a*(c+u);n&&f%100==0&&console.log(`Step ${f+1}: t = ${i}, k1v = ${e}, k1y = ${r}, k2v = ${l}, k2y = ${o}, k3v = ${u}, k3y = ${h}, k4v = ${m}, k4y = ${d}`),s+=(r+2*o+2*h+d)/6,c+=(e+2*l+2*u+m)/6,i+=a,g.push([i,s,c]),f++}return n&&console.log("RK4_2nd Method End"),g}}class l{static newtonRaphson(t,e,r,l=1e-6,o=100){let a,n=r;for(let r=0;r<o;r++){let r=t(n),o=e(n);if(Math.abs(o)<1e-12)throw new Error("Derivative too small.");if(a=n,n-=r/o,Math.abs(n-a)<=l)return n}throw new Error("Max iterations reached.")}static secant(t,e,r,l=1e-6,o=100){let a=0;for(;Math.abs(r-e)>l&&a<o;){let l=t(e),o=t(r);if(l===o)throw new Error("Function values are equal.");let n=r-(r-e)/(o-l)*o;e=r,r=n,a++}return r}}class o{static jacobi(t,e,r,l,o,a=!1){let n=r.length,i=Array(n).fill(0);a&&console.log("Starting Jacobi method..."),a&&console.log(`Initial guess: ${r}`),a&&console.log(`Matrix A: ${JSON.stringify(t)}`),a&&console.log(`Vector b: ${JSON.stringify(e)}`),a&&console.log(`Tolerance: ${o}, Max iterations: ${l}`);for(let s=0;s<l;s++){a&&s%10==0&&console.log(`Iteration ${s}: Current guess: ${r}`);for(let l=0;l<n;l++){let o=0;for(let e=0;e<n;e++)e!==l&&(o+=t[l][e]*r[e]);i[l]=(e[l]-o)/t[l][l]}if(i.every(((t,e)=>Math.abs(t-r[e])<o)))return a&&console.log(`Convergence reached at iteration ${s}`),i;r=[...i]}return a&&console.log("Maximum iterations reached without full convergence."),r}static gaussSeidel(t,e,r,l,o,a=!1){let n=r.length;a&&console.log("Starting Gauss-Seidel method..."),a&&console.log(`Initial guess: ${r}`),a&&console.log(`Matrix A: ${JSON.stringify(t)}`),a&&console.log(`Vector b: ${JSON.stringify(e)}`),a&&console.log(`Tolerance: ${o}, Max iterations: ${l}`);for(let i=0;i<l;i++){a&&i%10==0&&console.log(`Iteration ${i}: Current guess: ${r}`);let l=[...r];for(let l=0;l<n;l++){let o=0;for(let e=0;e<n;e++)e!==l&&(o+=t[l][e]*r[e]);r[l]=(e[l]-o)/t[l][l]}if(r.every(((t,e)=>Math.abs(t-l[e])<o)))return a&&console.log(`Convergence reached at iteration ${i}`),r}return a&&console.log("Maximum iterations reached without full convergence."),r}}class a{static differentiate(t,e,r=1e-5){return(t(e+r)-t(e-r))/(2*r)}static trapezoidal(t,e,r,l=100){let o=(r-e)/l,a=.5*(t(e)+t(r));for(let r=1;r<l;r++)a+=t(e+r*o);return a*o}}class n{static multiply(t,e){let r=t.length,l=t[0].length,o=e.length,a=e[0].length;if(l!==o)throw new Error("Matrix dimensions do not match");let n=Array(r).fill().map((()=>Array(a).fill(0)));for(let o=0;o<r;o++)for(let r=0;r<a;r++)for(let a=0;a<l;a++)n[o][r]+=t[o][a]*e[a][r];return n}static transpose(t){return t[0].map(((e,r)=>t.map((t=>t[r]))))}static determinant(t){if(t.length!==t[0].length)throw new Error("Matrix must be square");let e=t.length;if(1===e)return t[0][0];if(2===e)return t[0][0]*t[1][1]-t[0][1]*t[1][0];let r=0;for(let l=0;l<e;l++){let e=t.slice(1).map((t=>t.filter(((t,e)=>e!==l))));r+=(l%2==0?1:-1)*t[0][l]*this.determinant(e)}return r}static inverse(t){let e=t.length,r=t.map(((t,e)=>t.map(((t,r)=>e===r?1:0)))),l=t.map((t=>[...t]));for(let t=0;t<e;t++){let o=l[t][t];if(0===o)throw new Error("Matrix is singular and cannot be inverted");for(let a=0;a<e;a++)l[t][a]/=o,r[t][a]/=o;for(let o=0;o<e;o++)if(o!==t){let a=l[o][t];for(let n=0;n<e;n++)l[o][n]-=a*l[t][n],r[o][n]-=a*r[t][n]}}return r}}class i{constructor(t,e){this.real=t,this.imag=e}add(t){return new i(this.real+t.real,this.imag+t.imag)}subtract(t){return new i(this.real-t.real,this.imag-t.imag)}multiply(t){return new i(this.real*t.real-this.imag*t.imag,this.real*t.imag+this.imag*t.real)}divide(t){let e=t.real**2+t.imag**2;return new i((this.real*t.real+this.imag*t.imag)/e,(this.imag*t.real-this.real*t.imag)/e)}}class s{static omega(t,e){let r=2*Math.PI*e/t;return new i(Math.cos(r),Math.sin(r))}static fft(t){let e=t.length;if(1===e)return t;let r=t.filter(((t,e)=>e%2==0)),l=t.filter(((t,e)=>e%2!=0)),o=s.fft(r),a=s.fft(l),n=new Array(e);for(let t=0;t<e/2;t++){let r=s.omega(e,t);n[t]=o[t].add(r.multiply(a[t])),n[t+e/2]=o[t].subtract(r.multiply(a[t]))}return n}static ifft(t){let e=t.length;return s.fft(t.map((t=>new i(t.real,-t.imag)))).map((t=>new i(t.real/e,t.imag/e)))}}class c{static needlemanWunsch(t,e,r=1,l=-1,o=-2){let a=t.length,n=e.length,i=Array.from({length:a+1},(()=>Array(n+1).fill(0)));for(let t=0;t<=a;t++)i[t][0]=t*o;for(let t=0;t<=n;t++)i[0][t]=t*o;for(let s=1;s<=a;s++)for(let a=1;a<=n;a++){let n=t[s-1]===e[a-1]?r:l;i[s][a]=Math.max(i[s-1][a-1]+n,i[s-1][a]+o,i[s][a-1]+o)}return i[a][n]}}class g{static navierStokes2D(t,e,r,l,o=!1){let a=t.length,n=t[0].length,i=Array.from({length:a},(()=>Array(n).fill([0,0])));o&&(console.log("Starting 2D Navier-Stokes simulation..."),console.log(`Grid size: ${a}x${n}`),console.log(`Time step (dt): ${e}`),console.log(`Viscosity: ${r}`),console.log(`Iterations: ${l}`));for(let t=0;t<l;t++){if(o){let e=Math.floor((t+1)/l*100);e%5==0&&console.log(`Progress: ${e}% (${t+1} / ${l} iterations)`)}for(let t=1;t<a-1;t++)for(let l=1;l<n-1;l++){let[o,s]=i[t][l],c=(i[t-1][l][0]+i[t+1][l][0]+i[t][l-1][0]+i[t][l+1][0]-4*o)/(a*n),g=(i[t-1][l][1]+i[t+1][l][1]+i[t][l-1][1]+i[t][l+1][1]-4*s)/(a*n);i[t][l]=[o+e*(r*c),s+e*(r*g)]}}return o&&console.log(`Simulation completed after ${l} iterations.`),i}}class f{static oneDBarElement(t,e,r,l){let o=l+1;for(let l=0;l<o;l++){let a=e[l];for(let e=0;e<o;e++)a-=t[l][e]*r[e];r[l]=a/t[l][l]}return r}}class u{static lorenzAttractor(t,e,l,o=1,a=1,n=1,i=.01,s=5e3,c=!1){return r.rk4(((r,o)=>{let[a,n,i]=o;return[t*(n-a),a*(e-i)-n,a*n-l*i]}),0,[o,a,n],i,s,c)}static simplePendulum(t,e,l=9.81,o=.01,a=1e3,n=!1){return r.rk4(((t,r)=>{let[o,a]=r;return[a,-l/e*Math.sin(o)]}),0,[t,0],o,a,n)}static projectileMotion(t,e,l=0,o=9.81,a=.01,n=1e3,i=!1){let s=e*Math.PI/180,c=t*Math.cos(s),g=t*Math.sin(s),f=r.rk4_2nd(((t,e,r)=>[r,-l*r]),0,c,0,n*a,a,i),u=r.rk4_2nd(((t,e,r)=>[r,-o-l*r]),0,g,0,n*a,a,i),h=[];for(let t=0;t<n;t++)h.push([f[t][0],u[t][0]]);return h}}class h{static lowPassFilter(t,e){let r=t.length,l=s.fft(t.map((t=>new i(t,0)))).map(((t,l)=>l/r>e?new i(0,0):t));return s.ifft(l).map((t=>t.real))}static powerSpectrum(t){let e=t.length;return s.fft(t.map((t=>new i(t,0)))).map((t=>(t.real**2+t.imag**2)/e))}}class m{static mean(t){return t.reduce(((t,e)=>t+e),0)/t.length}static median(t){t.sort(((t,e)=>t-e));let e=Math.floor(t.length/2);return t.length%2==0?(t[e-1]+t[e])/2:t[e]}static variance(t){let e=this.mean(t);return this.mean(t.map((t=>(t-e)**2)))}static stddev(t){return Math.sqrt(this.variance(t))}}return e})(),"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SciCompute=t():this.SciCompute=t();